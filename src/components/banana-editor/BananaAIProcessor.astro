---
// BananaEditor AIå¤„ç†å™¨ç»„ä»¶ï¼ˆé‡æ„ç‰ˆï¼‰
// ä¸SessionManageré›†æˆï¼Œå¤„ç†ç”¨æˆ·æ¶ˆæ¯å¹¶è°ƒç”¨äº‘å‡½æ•°ç”Ÿæˆå›¾ç‰‡

export interface Props {
  className?: string;
}

const { className = "" } = Astro.props;
---

<div class={`banana-ai-processor ${className}`} id="banana-ai-processor">
  <!-- è¿™ä¸ªç»„ä»¶ä¸»è¦åŒ…å«JavaScripté€»è¾‘ï¼Œæ²¡æœ‰å¯è§çš„UI -->
</div>

<script>
  // BananaEditor AIå¤„ç†å™¨ç±»ï¼ˆé‡æ„ç‰ˆï¼‰
  class BananaAIProcessor {
    cloudFunctionUrl: string;
    isProcessing: boolean;
    isInitializing: boolean;
    currentActiveImage: string | null;

    constructor() {
      // æ ¹æ®ç¯å¢ƒé€‰æ‹©äº‘å‡½æ•°URL
      // å¼€å‘ç¯å¢ƒä½¿ç”¨ v2ï¼ˆåŒ…å«ç§¯åˆ†ç³»ç»Ÿï¼‰ï¼Œç”Ÿäº§ç¯å¢ƒä½¿ç”¨ v1
      const isDev =
        import.meta.env.DEV || import.meta.env.MODE === "development";

      if (isDev && import.meta.env.PUBLIC_FIREBASE_FUNCTION_URL_DEV) {
        // å¼€å‘ç¯å¢ƒï¼šä½¿ç”¨ v2 ç‰ˆæœ¬ï¼ˆå¸¦ç§¯åˆ†æ£€æŸ¥ï¼‰
        this.cloudFunctionUrl =
          import.meta.env.PUBLIC_FIREBASE_FUNCTION_URL_DEV;
        console.log("ğŸŸ¢ [å¼€å‘ç¯å¢ƒ] ä½¿ç”¨äº‘å‡½æ•° v2 (å¸¦ç§¯åˆ†ç³»ç»Ÿ)");
      } else {
        // ç”Ÿäº§ç¯å¢ƒï¼šä½¿ç”¨ v1 ç‰ˆæœ¬
        this.cloudFunctionUrl =
          import.meta.env.PUBLIC_FIREBASE_FUNCTION_URL ||
          import.meta.env.PUBLIC_CLOUD_FUNCTION_URL ||
          "https://bananaaigenerator-vs5qoxox3a-uc.a.run.app";
        console.log("ğŸ”µ [ç”Ÿäº§ç¯å¢ƒ] ä½¿ç”¨äº‘å‡½æ•° v1");
      }

      this.isProcessing = false;
      this.isInitializing = true; // é˜²æ­¢åˆå§‹åŒ–æ—¶é‡å¤æ¸²æŸ“
      this.currentActiveImage = null; // å½“å‰ Canvas æ¿€æ´»çš„å›¾ç‰‡ URL
      this.init();
    }

    init() {
      // ç›‘å¬ç”¨æˆ·æ¶ˆæ¯å¤„ç†äº‹ä»¶
      window.addEventListener("sendMessage", (e: any) => {
        this.processUserMessage(e.detail);
      });

      // ç­‰å¾…SessionManageråˆå§‹åŒ–
      this.waitForSessionManager();

      // è®¾ç½®å…¨å±€æ–¹æ³•
      this.setupGlobalMethods();

      // ç›‘å¬ Canvas DOM å˜åŒ–
      this.setupCanvasObserver();

      console.log("ğŸŒ BananaAI Processor initialized (Session-based)");
      console.log("ğŸ“ Cloud Function URL:", this.cloudFunctionUrl);

      // æµ‹è¯•äº‘å‡½æ•°è¿æ¥ï¼ˆæš‚æ—¶ç¦ç”¨ä»¥è°ƒè¯• Canvas é—®é¢˜ï¼‰
      // if (
      //   this.cloudFunctionUrl &&
      //   !this.cloudFunctionUrl.includes("your-project-id")
      // ) {
      //   setTimeout(() => {
      //     this.testCloudFunction();
      //   }, 1000);
      // }
    }

    // ç­‰å¾…SessionManageråˆå§‹åŒ–
    waitForSessionManager() {
      const checkSessionManager = () => {
        if (window.sessionManager) {
          this.setupSessionEvents();

          // âš ï¸ æ³¨æ„ï¼šèŠå¤©å†å²ç°åœ¨ç”± React ç»„ä»¶ç®¡ç†ï¼Œè¿™é‡Œåªå¤„ç†ç”»å¸ƒ
          // æ¸²æŸ“å½“å‰ä¼šè¯çš„ç”»å¸ƒ
          const session = window.sessionManager?.getCurrentSession();
          if (session && session.lastImageUrl) {
            this.updateCanvasWithImage(session.lastImageUrl);
          }

          this.updateSessionStatus();

          // åˆå§‹åŒ–å®Œæˆï¼Œå…è®¸å¤„ç†æ–°æ¶ˆæ¯
          setTimeout(() => {
            this.isInitializing = false;
          }, 500);
        } else {
          setTimeout(checkSessionManager, 100);
        }
      };
      checkSessionManager();
    }

    // è®¾ç½®ä¼šè¯äº‹ä»¶ç›‘å¬
    setupSessionEvents() {
      // ç›‘å¬ä¼šè¯åˆ‡æ¢
      window.addEventListener("sessionSwitch", (e: any) => {
        // âš ï¸ æ³¨æ„ï¼šèŠå¤©å†å²ç°åœ¨ç”± React ç»„ä»¶ç®¡ç†ï¼Œè¿™é‡Œåªå¤„ç†ç”»å¸ƒ
        // this.renderCurrentSession(); // å·²ç¦ç”¨ï¼ŒReact ç»„ä»¶ä¼šå¤„ç†

        // æ›´æ–°ç”»å¸ƒæ˜¾ç¤ºå½“å‰ä¼šè¯çš„æœ€åä¸€å¼ å›¾ç‰‡
        const session = window.sessionManager?.getCurrentSession();
        if (session && session.lastImageUrl) {
          this.updateCanvasWithImage(session.lastImageUrl);
        } else {
          this.clearCanvas();
        }

        this.updateSessionStatus();
      });

      // ç›‘å¬æ¶ˆæ¯æ›´æ–° - åªæ›´æ–°çŠ¶æ€å’Œç”»å¸ƒï¼Œä¸æ˜¾ç¤ºæ¶ˆæ¯ï¼ˆé¿å…é‡å¤ï¼‰
      window.addEventListener("messageUpdate", (e: any) => {
        const { sessionId, message } = e.detail;
        // åªå¤„ç†å½“å‰ä¼šè¯çš„æ¶ˆæ¯ï¼Œä¸”ä¸æ˜¯æ­£åœ¨åˆå§‹åŒ–æ—¶
        if (
          sessionId === window.sessionManager.currentSessionId &&
          !this.isInitializing
        ) {
          this.updateSessionStatus();

          // å¦‚æœæ˜¯AIæ¶ˆæ¯ä¸”åŒ…å«å›¾ç‰‡ï¼Œæ›´æ–°ç”»å¸ƒ
          if (message.role === "model" && message.imageUrl) {
            this.updateCanvasWithImage(message.imageUrl);
          }
        }
      });

      // ç›‘å¬ä¼šè¯æ¸…ç©º
      window.addEventListener("sessionClear", (e: any) => {
        const { sessionId } = e.detail;
        if (sessionId === window.sessionManager.currentSessionId) {
          // âš ï¸ æ³¨æ„ï¼šèŠå¤©å†å²ç°åœ¨ç”± React ç»„ä»¶ç®¡ç†ï¼Œè¿™é‡Œåªæ¸…ç©ºç”»å¸ƒ
          // this.clearChatHistory(); // å·²ç¦ç”¨ï¼ŒReact ç»„ä»¶ä¼šå¤„ç†
          this.clearCanvas();
          this.updateSessionStatus();
        }
      });

      // ç›‘å¬å†å²å›¾ç‰‡é€‰æ‹©ï¼ˆç”¨æˆ·ç‚¹å‡» Generation History ä¸­çš„å›¾ç‰‡ï¼‰
      window.addEventListener("historyImageSelected", (e: any) => {
        const historyItem = e.detail;
        if (historyItem && historyItem.imageUrl) {
          console.log("ğŸ–¼ï¸ ç”¨æˆ·é€‰æ‹©å†å²å›¾ç‰‡:", historyItem.imageUrl);
          this.currentActiveImage = historyItem.imageUrl;
          this.updateCanvasWithImage(historyItem.imageUrl);
        }
      });
    }

    // å¤„ç†ç”¨æˆ·æ¶ˆæ¯
    async processUserMessage(messageData) {
      if (this.isProcessing) {
        console.log("AI is already processing, skipping...");
        return;
      }

      if (!window.sessionManager) {
        console.error("âŒ SessionManager not available");
        return;
      }

      this.isProcessing = true;

      // å¤„ç†ä¸åŒçš„æ•°æ®ç»“æ„ï¼š{message} æˆ– {text}
      const messageText = messageData.message || messageData.text;
      console.log("ğŸ“ Message text:", messageText);

      try {
        console.log("ğŸš€ Processing user message:", messageData);

        if (!messageText || !messageText.trim()) {
          throw new Error("Prompt is empty or undefined");
        }

        // è·å–å½“å‰ä¼šè¯çš„å¯¹è¯å†å²ï¼ˆæ’é™¤åˆšæ·»åŠ çš„ç”¨æˆ·æ¶ˆæ¯ï¼Œé¿å…é‡å¤å‘é€ï¼‰
        const conversationHistory =
          window.sessionManager.getCurrentConversationHistory(true);
        console.log(
          "ğŸ“š Current conversation history length (excluding current message):",
          conversationHistory.length
        );
        console.log(
          "ğŸ“š å®Œæ•´å¯¹è¯å†å²å†…å®¹:",
          JSON.stringify(conversationHistory, null, 2)
        );

        // ç”¨æˆ·æ¶ˆæ¯å·²ç»ç”± React ç»„ä»¶æ·»åŠ äº†ï¼Œè¿™é‡Œä¸éœ€è¦å†æ·»åŠ 
        // åªéœ€è¦å¤„ç† AI å“åº”

        // è°ƒç”¨äº‘å‡½æ•°ç”Ÿæˆå›¾ç‰‡
        const result = await this.callCloudFunction(
          messageText.trim(),
          conversationHistory
        );

        console.log("ğŸ” æ£€æŸ¥å“åº”æ¡ä»¶:", {
          resultType: typeof result,
          hasSuccess: "success" in result,
          successValue: result.success,
          successType: typeof result.success,
          resultKeys: Object.keys(result),
        });

        if (result.success) {
          // æ·»åŠ AIå“åº”åˆ°å½“å‰ä¼šè¯
          const aiMessage = window.sessionManager.addMessage({
            role: "model",
            content:
              result.data.generatedPrompt || "Image generated successfully!",
            imageUrl: result.data.imageUrl,
            timestamp: Date.now(),
          });

          // React ç»„ä»¶ä¼šè‡ªåŠ¨æ˜¾ç¤ºï¼Œè¿™é‡Œä¸éœ€è¦æ‰‹åŠ¨æ¸²æŸ“

          // å¦‚æœå“åº”åŒ…å«ç§¯åˆ†ä¿¡æ¯ï¼Œè§¦å‘ç§¯åˆ†æ›´æ–°äº‹ä»¶
          if (
            result.data.metadata &&
            result.data.metadata.creditsRemaining !== undefined
          ) {
            console.log(
              "ğŸ’° ç§¯åˆ†å·²æ›´æ–°ï¼Œå‰©ä½™:",
              result.data.metadata.creditsRemaining
            );
            window.dispatchEvent(
              new CustomEvent("creditsUpdated", {
                detail: {
                  credits: result.data.metadata.creditsRemaining,
                  userId: result.data.metadata.userId,
                },
              })
            );
          }

          // å‘é€æˆåŠŸå“åº”äº‹ä»¶
          window.dispatchEvent(
            new CustomEvent("aiResponse", {
              detail: {
                text:
                  result.data.generatedPrompt ||
                  "Image generated successfully!",
                status: "success",
                imageUrl: result.data.imageUrl,
                thumbnailUrl: result.data.thumbnailUrl,
                prompt: messageText,
                metadata: result.data.metadata,
                suggestions: result.data.suggestions,
              },
            })
          );
        } else {
          // æ·»åŠ é”™è¯¯æ¶ˆæ¯åˆ°å½“å‰ä¼šè¯
          const errorMessage = window.sessionManager.addMessage({
            role: "model",
            content:
              result.error?.message || "Generation failed, please try again",
            timestamp: Date.now(),
            isError: true,
          });

          // React ç»„ä»¶ä¼šè‡ªåŠ¨æ˜¾ç¤ºï¼Œè¿™é‡Œä¸éœ€è¦æ‰‹åŠ¨æ¸²æŸ“

          // å‘é€é”™è¯¯å“åº”äº‹ä»¶
          window.dispatchEvent(
            new CustomEvent("aiResponse", {
              detail: {
                text:
                  result.error?.message ||
                  "Generation failed, please try again",
                status: "error",
                prompt: messageText,
              },
            })
          );
        }
      } catch (error) {
        console.error("âŒ AI processing failed:", error);

        // æ·»åŠ é”™è¯¯æ¶ˆæ¯åˆ°å½“å‰ä¼šè¯
        if (window.sessionManager) {
          const errorMessage = window.sessionManager.addMessage({
            role: "model",
            content: `Generation failed: ${error.message}`,
            timestamp: Date.now(),
            isError: true,
          });

          // âš ï¸ æ³¨æ„ï¼šèŠå¤©å†å²ç°åœ¨ç”± React ç»„ä»¶ç®¡ç†ï¼Œæ¶ˆæ¯ä¼šé€šè¿‡ messageUpdate äº‹ä»¶è‡ªåŠ¨æ˜¾ç¤º
          // this.displayMessageInChat(errorMessage); // å·²ç¦ç”¨ï¼ŒReact ç»„ä»¶ä¼šå¤„ç†
        }

        // å‘é€é”™è¯¯å“åº”äº‹ä»¶
        window.dispatchEvent(
          new CustomEvent("aiResponse", {
            detail: {
              text: `Generation failed: ${error.message}`,
              status: "error",
              prompt: messageText,
            },
          })
        );
      } finally {
        this.isProcessing = false;
        // React ç»„ä»¶ä¼šè‡ªåŠ¨å¤„ç†æ€è€ƒçŠ¶æ€ï¼Œè¿™é‡Œä¸éœ€è¦æ‰‹åŠ¨éšè—
      }
    }

    // è°ƒç”¨äº‘å‡½æ•° - ä½¿ç”¨åŠ å¯†å®¢æˆ·ç«¯
    async callCloudFunction(prompt, conversationHistory = []) {
      console.log("ğŸ”§ callCloudFunction called with:", {
        prompt,
        promptType: typeof prompt,
        promptLength: prompt ? prompt.length : "undefined",
        historyLength: conversationHistory.length,
        cloudFunctionUrl: this.cloudFunctionUrl,
      });

      if (
        !this.cloudFunctionUrl ||
        this.cloudFunctionUrl.includes("your-project-id")
      ) {
        throw new Error(
          "äº‘å‡½æ•° URL æœªé…ç½®ï¼Œè¯·è¿è¡Œ: npm run config:frontend configure"
        );
      }

      if (!prompt || typeof prompt !== "string" || !prompt.trim()) {
        throw new Error("æç¤ºè¯å‚æ•°æ— æ•ˆ");
      }

      console.log("ğŸ” ä½¿ç”¨åŠ å¯†å®¢æˆ·ç«¯è°ƒç”¨äº‘å‡½æ•°...");

      try {
        // å¯¼å…¥åŠ å¯†å®¢æˆ·ç«¯
        const { SecureBananaAIProcessor } = await import(
          "../../utils/secure-api-client.ts"
        );

        // åˆ›å»ºåŠ å¯†å¤„ç†å™¨
        const secureProcessor = new SecureBananaAIProcessor(
          this.cloudFunctionUrl
        );

        // æ„å»ºè¯·æ±‚æ•°æ®
        const requestData = {
          prompt: prompt.trim(),
          style: "realistic",
          quality: "high",
          creativity: 70,
          colorTone: "",
          outputFormat: "jpeg",
          conversationHistory: conversationHistory,
        };

        // å¦‚æœæœ‰å½“å‰æ¿€æ´»çš„å›¾ç‰‡ï¼Œè½¬ä¸º base64 å‘é€ï¼ˆç”¨äºä¿®æ”¹ï¼‰
        if (this.currentActiveImage) {
          console.log(
            "ğŸ–¼ï¸ æ£€æµ‹åˆ°æ¿€æ´»å›¾ç‰‡ï¼Œè½¬æ¢ä¸º base64:",
            this.currentActiveImage
          );
          try {
            const base64 = await this.imageUrlToBase64(this.currentActiveImage);
            if (base64) {
              requestData.currentActiveImage = {
                url: this.currentActiveImage,
                base64: base64,
              };
              console.log("âœ… å½“å‰æ¿€æ´»å›¾ç‰‡å·²æ·»åŠ åˆ°è¯·æ±‚ä¸­");
            }
          } catch (error) {
            console.error("âŒ å›¾ç‰‡è½¬æ¢å¤±è´¥:", error);
          }
        }

        console.log("ğŸ“¤ å‘é€åŠ å¯†è¯·æ±‚æ•°æ®:", {
          promptLength: prompt.length,
          historyLength: conversationHistory.length,
          hasActiveImage: !!requestData.currentActiveImage,
          imageDataSize: requestData.currentActiveImage?.base64?.length || 0,
        });

        // ä½¿ç”¨åŠ å¯†å®¢æˆ·ç«¯è°ƒç”¨
        console.log("ğŸ”„ å¼€å§‹è°ƒç”¨åŠ å¯†å®¢æˆ·ç«¯...");
        const result = await secureProcessor.callCloudFunction(
          requestData,
          requestData.currentActiveImage
        );

        console.log("âœ… åŠ å¯†äº‘å‡½æ•°è°ƒç”¨æˆåŠŸ:", result);
        console.log("ğŸ“Š å“åº”æ•°æ®ç»“æ„:", {
          hasSuccess: "success" in result,
          successValue: result.success,
          hasData: "data" in result,
          dataKeys: result.data ? Object.keys(result.data) : "no data",
          fullResult: result,
        });
        return result;
      } catch (error) {
        console.error("âŒ åŠ å¯†äº‘å‡½æ•°è°ƒç”¨å¤±è´¥:", error);
        console.error("âŒ é”™è¯¯è¯¦æƒ…:", {
          message: error.message,
          name: error.name,
          stack: error.stack,
        });
        throw error;
      }
    }

    // æ¸²æŸ“å½“å‰ä¼šè¯
    renderCurrentSession() {
      const session = window.sessionManager
        ? window.sessionManager.getCurrentSession()
        : null;
      if (!session) {
        this.clearChatHistory();
        this.clearCanvas();
        return;
      }

      console.log("ğŸ”„ Rendering session:", session.id, session.title);

      // æ¸…ç©ºèŠå¤©å†å²
      this.clearChatHistory();

      // æ¸²æŸ“ä¼šè¯æ¶ˆæ¯
      session.messages.forEach((message) => {
        this.displayMessageInChat(message);
      });

      // æ›´æ–°ç”»å¸ƒæ˜¾ç¤ºæœ€åçš„å›¾ç‰‡
      if (session.lastImageUrl) {
        this.updateCanvasWithImage(session.lastImageUrl);
      } else {
        this.clearCanvas();
      }
    }

    // ä»…æ˜¾ç¤ºæ¶ˆæ¯åˆ°èŠå¤©ç•Œé¢
    displayMessageInChat(message) {
      const chatHistory = document.getElementById("chat-history");
      if (!chatHistory) return;

      // éšè—ç©ºçŠ¶æ€
      const historyEmpty = chatHistory.querySelector(".history-empty");
      if (historyEmpty) {
        historyEmpty.style.display = "none";
      }

      // åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
      const messageElement = this.createMessageElement(message);
      chatHistory.appendChild(messageElement);

      // æ»šåŠ¨åˆ°åº•éƒ¨
      chatHistory.scrollTop = chatHistory.scrollHeight;

      // æ·»åŠ åŠ¨ç”»æ•ˆæœ
      setTimeout(() => {
        messageElement.classList.add("message-visible");
      }, 10);
    }

    // åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
    createMessageElement(message) {
      const messageDiv = document.createElement("div");
      messageDiv.className = `chat-message ${message.role}-message`;

      if (message.isError) {
        messageDiv.classList.add("error-message");
      }

      const timestamp = new Date(message.timestamp).toLocaleTimeString(
        "zh-CN",
        {
          hour: "2-digit",
          minute: "2-digit",
        }
      );

      // èŠå¤©çª—å£åªæ˜¾ç¤ºæ–‡æœ¬å†…å®¹ï¼Œä¸æ˜¾ç¤ºå›¾ç‰‡
      const userIcon = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
        <circle cx="12" cy="7" r="4"></circle>
      </svg>`;

      const aiIcon = `ğŸŒ`;

      let messageHTML = `
        <div class="message-header">
          <div class="message-avatar ${message.role}">
            ${message.role === "user" ? userIcon : aiIcon}
          </div>
          <div class="message-info">
            <span class="message-sender">${message.role === "user" ? "You" : "BananaAI"}</span>
            <span class="message-time">${timestamp}</span>
          </div>
        </div>
        <div class="message-content">
          <div class="message-text">${this.formatMessageText(message.content)}</div>
      `;

      // å¦‚æœAIæ¶ˆæ¯åŒ…å«å›¾ç‰‡ï¼Œåªæ˜¾ç¤ºæç¤ºæ–‡æœ¬
      if (message.role === "model" && message.imageUrl) {
        messageHTML += `
          <div class="image-generated-notice">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <circle cx="8.5" cy="8.5" r="1.5"></circle>
              <polyline points="21,15 16,10 5,21"></polyline>
            </svg>
            <span>Image generated and displayed on the right canvas</span>
          </div>
        `;
      }

      messageHTML += `</div>`;
      messageDiv.innerHTML = messageHTML;
      return messageDiv;
    }

    // æ ¼å¼åŒ–æ¶ˆæ¯æ–‡æœ¬
    formatMessageText(text) {
      return text.replace(/\n/g, "<br>");
    }

    // æ˜¾ç¤ºAIæ€è€ƒçŠ¶æ€
    showAIThinking() {
      const chatHistory = document.getElementById("chat-history");
      if (!chatHistory) return;

      // ç§»é™¤ä¹‹å‰çš„æ€è€ƒçŠ¶æ€
      const existingThinking = chatHistory.querySelector(".ai-thinking");
      if (existingThinking) {
        existingThinking.remove();
      }

      const thinkingDiv = document.createElement("div");
      thinkingDiv.className = "chat-message model-message ai-thinking";
      thinkingDiv.innerHTML = `
        <div class="message-header">
          <div class="message-avatar model">ğŸ¤–</div>
          <div class="message-info">
            <span class="message-sender">BananaAI</span>
            <span class="message-time">Thinking...</span>
          </div>
        </div>
        <div class="message-content">
          <div class="thinking-animation">
            <div class="thinking-dots">
              <span></span>
              <span></span>
              <span></span>
            </div>
            <span class="thinking-text">AI is generating image, please wait...</span>
          </div>
        </div>
      `;

      chatHistory.appendChild(thinkingDiv);
      chatHistory.scrollTop = chatHistory.scrollHeight;

      setTimeout(() => {
        thinkingDiv.classList.add("message-visible");
      }, 10);
    }

    // éšè—AIæ€è€ƒçŠ¶æ€
    hideAIThinking() {
      const thinkingElement = document.querySelector(".ai-thinking");
      if (thinkingElement) {
        thinkingElement.remove();
      }
    }

    // æ¸…ç©ºèŠå¤©å†å²æ˜¾ç¤º
    clearChatHistory() {
      const chatHistory = document.getElementById("chat-history");
      if (chatHistory) {
        chatHistory.innerHTML = `
          <div class="history-empty">
            <div class="empty-icon">Chat</div>
            <p class="empty-text">
              Start a conversation, describe the image effect you want
            </p>
          </div>
        `;
      }
    }

    // æ¸…ç©ºç”»å¸ƒ
    clearCanvas() {
      const canvasEmpty = document.getElementById("canvas-empty");
      const canvasImage = document.getElementById("canvas-image");

      if (canvasEmpty && canvasImage) {
        canvasEmpty.style.display = "block";
        canvasImage.style.display = "none";
      }
    }

    // æ›´æ–°ç”»å¸ƒæ˜¾ç¤ºå›¾ç‰‡
    updateCanvasWithImage(imageUrl) {
      try {
        const canvasEmpty = document.getElementById("canvas-empty");
        const canvasImage = document.getElementById("canvas-image");
        const currentImage = document.getElementById("current-image");

        if (canvasEmpty && canvasImage && currentImage && imageUrl) {
          // éšè—ç©ºçŠ¶æ€
          canvasEmpty.style.display = "none";

          // æ˜¾ç¤ºå›¾ç‰‡
          currentImage.src = imageUrl;
          currentImage.alt = "AIç”Ÿæˆçš„å›¾ç‰‡";
          canvasImage.style.display = "block";

          // æ›´æ–°å½“å‰æ¿€æ´»å›¾ç‰‡
          this.currentActiveImage = imageUrl;

          // æ›´æ–°å›¾ç‰‡ä¿¡æ¯
          this.updateImageInfo({ imageUrl });

          console.log("ğŸ–¼ï¸ Canvas updated with image:", imageUrl);
        }
      } catch (error) {
        console.error("âŒ Failed to update canvas with image:", error);
      }
    }

    // å°†å›¾ç‰‡ URL è½¬ä¸º base64
    async imageUrlToBase64(imageUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous"; // å…è®¸è·¨åŸŸ

        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;

            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);

            // è½¬ä¸º base64ï¼ˆç§»é™¤ "data:image/jpeg;base64," å‰ç¼€ï¼‰
            const base64 = canvas.toDataURL("image/jpeg", 0.9).split(",")[1];
            resolve(base64);
          } catch (error) {
            console.error("Canvas è½¬æ¢å¤±è´¥:", error);
            reject(error);
          }
        };

        img.onerror = (error) => {
          console.error("å›¾ç‰‡åŠ è½½å¤±è´¥:", error);
          reject(error);
        };

        img.src = imageUrl;
      });
    }

    // æ›´æ–°å›¾ç‰‡ä¿¡æ¯
    updateImageInfo(data) {
      const imageDimensions = document.getElementById("image-dimensions");
      const imageSize = document.getElementById("image-size");

      if (imageDimensions) {
        imageDimensions.textContent = "1024Ã—1024"; // é»˜è®¤å°ºå¯¸
      }

      if (imageSize) {
        imageSize.textContent = "-- KB"; // æ— æ³•è·å–ç¡®åˆ‡å¤§å°
      }
    }

    // æ›´æ–°ä¼šè¯çŠ¶æ€æ˜¾ç¤º
    updateSessionStatus() {
      const statusElement = document.getElementById("conversation-status");
      if (!statusElement) return;

      const statusText = statusElement.querySelector(".status-text");
      if (!statusText) return;

      const session = window.sessionManager
        ? window.sessionManager.getCurrentSession()
        : null;

      if (!session || session.messages.length === 0) {
        statusText.textContent = "Ready to start conversation";
        statusElement.style.background =
          "linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(16, 185, 129, 0.05) 100%)";
        statusElement.style.borderColor = "rgba(34, 197, 94, 0.2)";
        statusElement.style.color = "#059669";
      } else {
        const conversationCount = Math.floor(session.messages.length / 2);
        statusText.textContent = `${session.title} - ${conversationCount} conversations`;
        statusElement.style.background =
          "linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%)";
        statusElement.style.borderColor = "rgba(59, 130, 246, 0.2)";
        statusElement.style.color = "#2563eb";
      }
    }

    // è®¾ç½®å…¨å±€æ–¹æ³•
    setupGlobalMethods() {
      // å›¾ç‰‡é¢„è§ˆ
      window.openImagePreview = (imageUrl) => {
        const fullscreenModal = document.getElementById("fullscreen-modal");
        const fullscreenImage = document.getElementById("fullscreen-image");
        const modalOverlay = document.getElementById("modal-overlay");

        if (fullscreenModal && fullscreenImage && modalOverlay) {
          fullscreenImage.src = imageUrl;
          modalOverlay.style.display = "block";
          fullscreenModal.style.display = "block";
        }
      };

      // ä¸‹è½½å›¾ç‰‡
      window.downloadImage = async (imageUrl) => {
        try {
          const response = await fetch(imageUrl);
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `banana-ai-image-${Date.now()}.jpg`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        } catch (error) {
          console.error("ä¸‹è½½å›¾ç‰‡å¤±è´¥:", error);
        }
      };

      // å¤åˆ¶å›¾ç‰‡é“¾æ¥
      window.copyImageUrl = async (imageUrl) => {
        try {
          await navigator.clipboard.writeText(imageUrl);
          this.showToast("å›¾ç‰‡é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
        } catch (error) {
          console.error("å¤åˆ¶é“¾æ¥å¤±è´¥:", error);
          this.showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
        }
      };

      // æ¸…ç©ºå½“å‰ä¼šè¯çš„å…¨å±€æ–¹æ³•
      window.clearCurrentSession = () => {
        if (window.sessionManager) {
          window.sessionManager.clearCurrentSession();
        }
      };

      // å¯¼å‡ºå½“å‰ä¼šè¯çš„å…¨å±€æ–¹æ³•
      window.exportCurrentSession = () => {
        if (window.sessionManager) {
          const exportData = window.sessionManager.exportCurrentSession();
          if (exportData) {
            this.downloadJSON(exportData, `banana-session-${Date.now()}.json`);
            this.showToast("ä¼šè¯å¯¼å‡ºæˆåŠŸ");
          }
        }
      };
    }

    // å·¥å…·æ–¹æ³•
    downloadJSON(data, filename) {
      const dataStr = JSON.stringify(data, null, 2);
      const dataBlob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(dataBlob);

      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      URL.revokeObjectURL(url);
    }

    // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
    showToast(message) {
      const toast = document.createElement("div");
      toast.className = "toast-message";
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #10b981;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        z-index: 10000;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.3s ease;
      `;

      document.body.appendChild(toast);

      setTimeout(() => {
        toast.style.opacity = "1";
        toast.style.transform = "translateY(0)";
      }, 10);

      setTimeout(() => {
        toast.style.opacity = "0";
        toast.style.transform = "translateY(-10px)";
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 300);
      }, 3000);
    }

    // è·å–å¤„ç†çŠ¶æ€
    isCurrentlyProcessing() {
      return this.isProcessing;
    }

    // ç›‘å¬ Canvas DOM å˜åŒ–
    setupCanvasObserver() {
      const canvasEmpty = document.getElementById("canvas-empty");
      const canvasImage = document.getElementById("canvas-image");

      if (!canvasEmpty || !canvasImage) return;

      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (
            mutation.type === "attributes" &&
            mutation.attributeName === "style"
          ) {
            const target = mutation.target;
            const display = window.getComputedStyle(target).display;
            console.log(
              `ğŸ” [Canvas Observer] ${target.id} style changed to display: ${display}`
            );
            console.trace("Stack trace:");
          }
        });
      });

      observer.observe(canvasEmpty, {
        attributes: true,
        attributeFilter: ["style"],
      });
      observer.observe(canvasImage, {
        attributes: true,
        attributeFilter: ["style"],
      });

      console.log("ğŸ‘ï¸ Canvas observer setup complete");
    }

    // è®¾ç½®äº‘å‡½æ•°URL
    setCloudFunctionUrl(url) {
      this.cloudFunctionUrl = url;
      console.log("ğŸ”§ Cloud function URL updated:", url);
    }

    // æµ‹è¯•äº‘å‡½æ•°è¿æ¥
    async testCloudFunction() {
      try {
        console.log("ğŸ§ª Testing cloud function connection...");

        if (
          !this.cloudFunctionUrl ||
          this.cloudFunctionUrl.includes("your-project-id")
        ) {
          throw new Error("äº‘å‡½æ•° URL æœªé…ç½®");
        }

        // ä½¿ç”¨åŠ å¯†å®¢æˆ·ç«¯è¿›è¡Œå¥åº·æ£€æŸ¥
        try {
          const { SecureBananaAIProcessor } = await import(
            "../../utils/secure-api-client.ts"
          );
          const secureProcessor = new SecureBananaAIProcessor(
            this.cloudFunctionUrl
          );

          // å‘é€ä¸€ä¸ªç®€å•çš„æµ‹è¯•è¯·æ±‚
          const testResult = await secureProcessor.callCloudFunction(
            "æµ‹è¯•è¿æ¥",
            []
          );

          console.log("âœ… åŠ å¯†äº‘å‡½æ•°è¿æ¥æµ‹è¯•æˆåŠŸ");
          return true;
        } catch (encryptionError) {
          console.log("âš ï¸ åŠ å¯†è¿æ¥æµ‹è¯•å¤±è´¥ï¼Œå°è¯•ç›´æ¥è¿æ¥...");

          // å¦‚æœåŠ å¯†æµ‹è¯•å¤±è´¥ï¼Œå°è¯•ç›´æ¥è¿æ¥ï¼ˆç”¨äºè°ƒè¯•ï¼‰
          const response = await fetch(this.cloudFunctionUrl, {
            method: "GET",
            headers: {
              "User-Agent": "BananaEditor-Test/1.0",
            },
          });

          console.log("ğŸ§ª Test response status:", response.status);

          if (response.ok) {
            console.log("âœ… Cloud function is accessible (but not encrypted)");
            return true;
          } else {
            console.log("âš ï¸ Cloud function returned non-200 status");
            return false;
          }
        }
      } catch (error) {
        console.error("âŒ Cloud function test failed:", error);
        return false;
      }
    }
  }

  // åˆå§‹åŒ–AIå¤„ç†å™¨
  document.addEventListener("DOMContentLoaded", function () {
    const instance = new BananaAIProcessor();
    window.bananaAIProcessor = instance;

    // ä¸º React ç»„ä»¶æš´éœ²å®ä¾‹
    if (!window.BananaAIProcessor) {
      window.BananaAIProcessor = BananaAIProcessor;
    }
    window.BananaAIProcessor.instance = instance;
  });

  // å¯¼å‡ºåˆ°å…¨å±€ä½œç”¨åŸŸ
  window.BananaAIProcessor = BananaAIProcessor;
</script>

<style>
  .banana-ai-processor {
    display: none; /* è¿™ä¸ªç»„ä»¶æ²¡æœ‰å¯è§çš„UI */
  }

  /* èŠå¤©æ¶ˆæ¯æ ·å¼ */
  .chat-message {
    margin-bottom: 20px;
    opacity: 0;
    transform: translateY(10px);
    transition: all 0.3s ease;
    animation: slideIn 0.3s ease forwards;
  }

  .chat-message.message-visible {
    opacity: 1;
    transform: translateY(0);
  }

  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .message-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
  }

  .message-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    flex-shrink: 0;
  }

  .message-avatar.user {
    background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
    color: white;
  }

  .message-avatar.model {
    background: linear-gradient(135deg, #ffd700 0%, #ffa500 100%);
    color: #2d1810;
  }

  .message-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .message-sender {
    font-size: 14px;
    font-weight: 600;
    color: #1f2937;
  }

  .message-time {
    font-size: 12px;
    color: #6b7280;
  }

  .message-content {
    margin-left: 44px;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    position: relative;
  }

  .user-message .message-content {
    background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
    border-color: #bfdbfe;
  }

  .model-message .message-content {
    background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    border-color: #fde68a;
  }

  .error-message .message-content {
    background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
    border-color: #fca5a5;
  }

  .message-content::before {
    content: "";
    position: absolute;
    top: -8px;
    left: 20px;
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-bottom: 8px solid #e5e7eb;
  }

  .user-message .message-content::before {
    border-bottom-color: #bfdbfe;
  }

  .model-message .message-content::before {
    border-bottom-color: #fde68a;
  }

  .error-message .message-content::before {
    border-bottom-color: #fca5a5;
  }

  .message-text {
    font-size: 15px;
    line-height: 1.6;
    color: #374151;
    word-wrap: break-word;
  }

  /* å›¾ç‰‡ç”Ÿæˆæç¤º */
  .image-generated-notice {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    padding: 8px 12px;
    background: linear-gradient(
      135deg,
      rgba(34, 197, 94, 0.1) 0%,
      rgba(16, 185, 129, 0.05) 100%
    );
    border: 1px solid rgba(34, 197, 94, 0.2);
    border-radius: 8px;
    font-size: 13px;
    color: #059669;
    font-weight: 500;
  }

  .image-generated-notice svg {
    flex-shrink: 0;
    opacity: 0.8;
  }

  /* AIæ€è€ƒåŠ¨ç”» */
  .ai-thinking .message-content {
    background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
    border-color: #d1d5db;
  }

  .thinking-animation {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .thinking-dots {
    display: flex;
    gap: 4px;
  }

  .thinking-dots span {
    width: 8px;
    height: 8px;
    background: #6b7280;
    border-radius: 50%;
    animation: thinking 1.4s infinite ease-in-out;
  }

  .thinking-dots span:nth-child(1) {
    animation-delay: -0.32s;
  }

  .thinking-dots span:nth-child(2) {
    animation-delay: -0.16s;
  }

  @keyframes thinking {
    0%,
    80%,
    100% {
      transform: scale(0.8);
      opacity: 0.5;
    }
    40% {
      transform: scale(1);
      opacity: 1;
    }
  }

  .thinking-text {
    font-size: 14px;
    color: #6b7280;
    font-style: italic;
  }

  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: 768px) {
    .message-content {
      margin-left: 0;
      margin-top: 8px;
    }

    .message-content::before {
      display: none;
    }

    .image-generated-notice {
      font-size: 12px;
      padding: 6px 10px;
    }
  }
</style>
